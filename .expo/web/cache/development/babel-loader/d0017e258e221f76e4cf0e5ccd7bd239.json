{"ast":null,"code":"'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n    getItemCount = props.getItemCount,\n    maxToRenderPerBatch = props.maxToRenderPerBatch,\n    windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  var offset = scrollMetrics.offset,\n    velocity = scrollMetrics.velocity,\n    visibleLength = scrollMetrics.visibleLength;\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n  var leadFactor = 0.5;\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  }\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n    overscanFirst = _elementsThatOverlapO[0],\n    first = _elementsThatOverlapO[1],\n    last = _elementsThatOverlapO[2],\n    overscanLast = _elementsThatOverlapO[3];\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  };\n  var newCellCount = newRangeCount(prev, visible);\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      break;\n    }\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      break;\n    }\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n  return {\n    first: first,\n    last: last\n  };\n}\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nexport { computeWindowedRenderLimits, elementsThatOverlapOffsets, newRangeCount };\nexport default VirtualizeUtils;","map":{"version":3,"names":["invariant","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils"],"sources":["/Users/jeko/Documents/Reactive-4twiggers-animation/node_modules/react-native-web/dist/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nimport invariant from 'fbjs/lib/invariant';\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\n\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          invariant(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nexport { computeWindowedRenderLimits, elementsThatOverlapOffsets, newRangeCount };\nexport default VirtualizeUtils;"],"mappings":"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"},"metadata":{},"sourceType":"module"}